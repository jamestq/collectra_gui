<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Annotation Viewer</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        .section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        input[type="file"] {
            padding: 10px;
            border: 2px dashed #007bff;
            border-radius: 4px;
            background: #f8f9ff;
            cursor: pointer;
        }
        input[type="file"]:hover {
            background: #e8f0ff;
        }
        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .result {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            margin-top: 10px;
            white-space: pre-wrap;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            max-height: 100px;
            overflow-y: auto;
        }
        .result.success {
            border-left: 4px solid #28a745;
        }
        .result.error {
            border-left: 4px solid #dc3545;
            background: #fff5f5;
        }
        .status {
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
        }
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        .main-content {
            display: flex;            
            gap: 20px;
        }
        .image-panel {
            flex: 0 0 600px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .image-panel h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .image-container {
            width: 100%;
            height: 500px;
            overflow: hidden;
            background: #f0f0f0;
            border-radius: 4px;
        }        
        .image-placeholder {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 40px;
        }
        .table-panel {
            flex: 1;
            min-width: 0;
        }
        #myGrid {
            height: 600px;
            width: 100%;
        }
        .folder-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        .folder-info .file-found {
            color: #28a745;
        }
        .folder-info .file-missing {
            color: #dc3545;
        }
        .app-container {
            display: flex;
            gap: 0;
        }
        .sidebar {
            width: 250px;
            min-width: 200px;
            background: #f8f9fa;
            border-right: 1px solid #ddd;
            display: none;
            flex-direction: column;
            height: calc(100vh - 120px);
            overflow: hidden;
            border-radius: 8px 0 0 8px;
        }
        .sidebar.visible {
            display: flex;
        }
        .sidebar-header {
            padding: 15px;
            background: #007bff;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 8px 0 0 0;
        }
        .sidebar-toggle {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }
        .sidebar-list {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            margin: 0;
            list-style: none;
        }
        .sidebar-item {
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sidebar-item:hover {
            background: #e9ecef;
        }
        .sidebar-item.active {
            background: #007bff;
            color: white;
        }
        .sidebar-item.loading {
            opacity: 0.6;
            pointer-events: none;
        }
        .sidebar-item .folder-icon {
            width: 20px;
            text-align: center;
        }
        .sidebar-item .folder-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .main-wrapper {
            flex: 1;
            min-width: 0;
        }
        /* Label Popup Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.visible {
            display: flex;
        }
        .modal-popup {
            background: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            min-width: 300px;
            max-width: 400px;
        }
        .modal-popup h3 {
            margin: 0 0 16px 0;
            color: #333;
        }
        .modal-popup input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 16px;
        }
        .modal-popup input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .modal-buttons .btn-cancel {
            background: #6c757d;
            color: white;
        }
        .modal-buttons .btn-cancel:hover {
            background: #5a6268;
        }
        .modal-buttons .btn-confirm {
            background: #007bff;
            color: white;
        }
        .modal-buttons .btn-confirm:hover {
            background: #0056b3;
        }
        /* Preset Labels Styles */
        .preset-labels {
            margin-bottom: 12px;
        }
        .preset-labels-title {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }
        .preset-labels-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 120px;
            overflow-y: auto;
        }
        .preset-label-btn {
            padding: 6px 12px;
            background: #e9ecef;
            border: 1px solid #ddd;
            color: #007bff;
            border-radius: 16px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .preset-label-btn:hover {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .preset-labels-empty {
            color: #999;
            font-style: italic;
            font-size: 12px;
        }
        .custom-label-divider {
            display: flex;
            align-items: center;
            margin: 12px 0;
            font-size: 12px;
            color: #999;
        }
        .custom-label-divider::before,
        .custom-label-divider::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid #ddd;
        }
        .custom-label-divider::before {
            margin-right: 10px;
        }
        .custom-label-divider::after {
            margin-left: 10px;
        }
        /* Global Stats Panel Styles */
        .stats-panel {
            display: none;
            background: #fff;
            border-bottom: 1px solid #ddd;
            padding: 12px 15px;
        }
        .stats-panel.visible {
            display: block;
        }
        .stats-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stats-content {
            font-size: 12px;
        }
        .stats-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        .stats-item:last-child {
            border-bottom: none;
        }
        .stats-label {
            color: #555;
        }
        .stats-count {
            font-weight: bold;
            color: #007bff;
        }
        .stats-total {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 2px solid #eee;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }
        .stats-total .stats-count {
            color: #28a745;
        }
    </style>
    <link rel="stylesheet" 
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" 
      integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" 
      crossorigin="anonymous" 
      referrerpolicy="no-referrer" /> 
    <script src="https://cdn.jsdelivr.net/npm/ag-grid-community/dist/ag-grid-community.min.js"></script>        
    <script src="https://cdn.jsdelivr.net/npm/openseadragon@5.0/build/openseadragon/openseadragon.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/@annotorious/openseadragon@latest/dist/annotorious-openseadragon.js"></script>
    <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@annotorious/openseadragon@latest/dist/annotorious-openseadragon.css">    
</head>
<body>
    <h1>Annotation Viewer</h1>

    <div id="status" class="status disconnected">
        Waiting for pywebview...
    </div>

    <div class="app-container">
        <aside id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <span>Folders</span>
                <button class="sidebar-toggle" onclick="toggleSidebar()" title="Hide sidebar">
                    <i class="fa fa-chevron-left"></i>
                </button>
            </div>
            <div id="globalStatsPanel" class="stats-panel">
                <div class="stats-header">
                    <span>Label Statistics</span>
                </div>
                <div id="globalStatsContent" class="stats-content">
                    <!-- Label counts populated dynamically -->
                </div>
            </div>
            <ul id="folderList" class="sidebar-list"></ul>
        </aside>

        <div class="main-wrapper">
            <div class="section">
                <div class="input-group">
                    <label><strong>Select .grapto folder:</strong></label>
                    <button id="selectFolderBtn" onclick="selectFolder()" disabled>Select .grapto Folder</button>
                    <button id="selectParentBtn" onclick="selectParentFolder()" disabled>Select Parent Folder</button>
                </div>
                <div id="folderInfo" class="folder-info"></div>
                <input type="hidden" id="yamlPath" value="">
                <div id="loadResult" class="result" style="display:none;"></div>
            </div>

            <div class="main-content">
                <div class="image-panel">
                    <h3>Image Preview</h3>
                    <div class="image-container" id="imageContainer">
                        <div class="image-placeholder">No image loaded. Select a folder containing an image file.</div>
                    </div>
                </div>
                <div class="table-panel section">
                    <div id="myGrid" class="ag-theme-quartz"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Label Popup Modal -->
    <div id="labelModal" class="modal-overlay">
        <div class="modal-popup">
            <h3>Enter Label Name</h3>
            <!-- Preset Labels Section -->
            <div class="preset-labels">
                <div class="preset-labels-title">Select from existing labels:</div>
                <div id="presetLabelsContainer" class="preset-labels-container">
                    <!-- Preset buttons will be populated here -->
                </div>
            </div>
            <div class="custom-label-divider">or enter custom</div>
            <input type="text" id="labelInput" placeholder="Enter custom label name..." autofocus>
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="cancelLabel()">Cancel</button>
                <button class="btn-confirm" onclick="confirmLabel()">Confirm</button>
            </div>
        </div>
    </div>

    <script>                

        let apiReady = false;
        let gridApi = null;
        let selectedYamlPath = '';
        let selectedImageFile = null;
        let anno = null;
        let viewer = null;
        let syncingSelection = false;
        let graptoFolders = [];
        let currentFolderIndex = -1;
        let sidebarVisible = false;
        let pendingAnnotation = null;
        let availableLabels = [];

        function formatLabelCounts(labelCounts) {
            const entries = Object.entries(labelCounts);
            if (entries.length === 0) {
                return '<span class="file-missing">No annotations found</span>';
            }
            return entries
                .sort((a, b) => b[1] - a[1])  // Sort by count descending
                .map(([label, count]) => `<span class="file-found">${label}: ${count}</span>`)
                .join('<br>');
        }

        function displayGlobalStats(labelCounts, total) {
            const panel = document.getElementById('globalStatsPanel');
            const content = document.getElementById('globalStatsContent');

            if (!labelCounts || Object.keys(labelCounts).length === 0) {
                panel.classList.remove('visible');
                return;
            }

            const entries = Object.entries(labelCounts).sort((a, b) => b[1] - a[1]);
            let html = '';

            entries.forEach(([label, count]) => {
                html += `<div class="stats-item">
                    <span class="stats-label">${label}</span>
                    <span class="stats-count">${count}</span>
                </div>`;
            });

            html += `<div class="stats-total">
                <span>Total</span>
                <span class="stats-count">${total}</span>
            </div>`;

            content.innerHTML = html;
            panel.classList.add('visible');
        }

        function hideGlobalStats() {
            const panel = document.getElementById('globalStatsPanel');
            panel.classList.remove('visible');
        }

        function showLabelPopup(annotation) {
            pendingAnnotation = annotation;
            const modal = document.getElementById('labelModal');
            const input = document.getElementById('labelInput');

            // Populate preset labels before showing
            populatePresetLabels();

            modal.classList.add('visible');
            input.value = '';
            input.focus();
        }

        function hideLabelPopup() {
            const modal = document.getElementById('labelModal');
            modal.classList.remove('visible');
            pendingAnnotation = null;
        }

        async function fetchAvailableLabels() {
            if (!apiReady) return;
            try {
                const result = await window.pywebview.api.get_available_labels();
                console.log('fetchAvailableLabels result:', result);
                if (result.success) {
                    availableLabels = result.labels;
                    console.log('availableLabels updated:', availableLabels);
                } else {
                    availableLabels = [];
                    console.warn('get_available_labels failed:', result.error);
                }
            } catch (e) {
                console.error('Error fetching labels:', e);
                availableLabels = [];
            }
        }

        function populatePresetLabels() {
            console.log('populatePresetLabels called, availableLabels:', availableLabels);
            const container = document.getElementById('presetLabelsContainer');
            container.innerHTML = '';

            if (availableLabels.length === 0) {
                container.innerHTML = '<span class="preset-labels-empty">No existing labels found</span>';
                return;
            }

            availableLabels.forEach(label => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'preset-label-btn';
                btn.textContent = label;
                btn.onclick = () => selectPresetLabel(label);
                container.appendChild(btn);
            });
        }

        function selectPresetLabel(label) {
            document.getElementById('labelInput').value = label;
            confirmLabel();
        }

        async function confirmLabel() {
            const input = document.getElementById('labelInput');
            const label = input.value.trim() || 'Untitled';

            if (!pendingAnnotation) {
                hideLabelPopup();
                return;
            }            
            try {
                const geometry = pendingAnnotation.target.selector.geometry;
                const cropRegion = calculateCropRegionFromGeometry(geometry);
                const allAnnotations = anno.getAnnotations();
                // Get the parent annotation (an bigger rectangle that contains this one)
                const parentAnnotations = allAnnotations.filter(ann => {
                    if (ann.id === pendingAnnotation.id) return false;
                    const parentGeom = ann.target.selector.geometry;
                    return (geometry.x > parentGeom.x &&
                            geometry.y > parentGeom.y &&
                            (geometry.x + geometry.w) < (parentGeom.x + parentGeom.w) &&
                            (geometry.y + geometry.h) < (parentGeom.y + parentGeom.h));
                });                
                const parentId = parentAnnotations.length > 0 ? parentAnnotations[parentAnnotations.length - 1].id : "";
                const result = await window.pywebview.api.create_annotation(cropRegion, label, parentId);
                if (result.success) {
                    // Update grid with new data
                    const display_data = result.rows.filter(row => row.type === "collectra.ImageCrop");
                    gridApi.setGridOption('rowData', display_data);

                    // Refresh annotations on image
                    anno.clearAnnotations();
                    display_data.forEach(row => {
                        const geom = calculateGeometryFromCropRegion(row.crop_region);
                        if (geom) anno.addAnnotation(createAnnotation(geom, row));
                    });

                    // Update global stats if in parent folder mode
                    if (graptoFolders.length > 0 && result.global_label_counts) {
                        displayGlobalStats(result.global_label_counts, result.global_total);
                    }

                    // Refresh available labels for next annotation
                    await fetchAvailableLabels();
                } else {
                    console.error('Error creating annotation:', result.error);
                }
            } catch (e) {
                console.error('Error creating annotation:', e);
            }

            hideLabelPopup();
        }

        function cancelLabel() {
            if (pendingAnnotation && anno) {
                // Remove the temporary annotation from the canvas
                anno.removeAnnotation(pendingAnnotation.id);
            }
            hideLabelPopup();
        }

        // Handle keyboard events for the modal
        document.addEventListener('keydown', function(e) {
            const modal = document.getElementById('labelModal');
            if (!modal.classList.contains('visible')) return;

            if (e.key === 'Escape') {
                cancelLabel();
            } else if (e.key === 'Enter') {
                confirmLabel();
            }
        });

        const updateCellValue = async (params) => {            
            try {
                const result = await window.pywebview.api.update_node_data(params.data.displaySourceId, params.newValue, params.data.id);
                if (!result.success) {
                    console.error('Failed to update node data:', result.error);
                }
                display_data = result.rows.filter(row => row.type === "collectra.ImageCrop");
                gridApi.setGridOption('rowData', display_data);
            } catch (e) {
                console.error('Error updating node data:', e);
            }
        };

        async function deleteAnnotation(nodeId) {
            if (!confirm('Delete this annotation?')) return;

            try {
                const result = await window.pywebview.api.delete_annotation(nodeId);
                if (result.success) {
                    const display_data = result.rows.filter(row => row.type === "collectra.ImageCrop");
                    gridApi.setGridOption('rowData', display_data);

                    // Refresh annotations on image
                    anno.clearAnnotations();
                    display_data.forEach(row => {
                        const geom = calculateGeometryFromCropRegion(row.crop_region);
                        if (geom) anno.addAnnotation(createAnnotation(geom, row));
                    });

                    // Update global stats if in parent folder mode
                    if (graptoFolders.length > 0 && result.global_label_counts) {
                        displayGlobalStats(result.global_label_counts, result.global_total);
                    }
                } else {
                    console.error('Error deleting annotation:', result.error);
                    alert('Failed to delete: ' + result.error);
                }
            } catch (e) {
                console.error('Error deleting annotation:', e);
                alert('Failed to delete annotation');
            }
        }

        const columnDefs = [
            { field: "id", headerName: "Node ID", filter: true, sortable: true, flex: 1 },            
            {
                field: "displayValue",
                headerName: "Display Value",
                filter: true,
                sortable: true,
                flex: 2,
                editable: (params) => !params.data.locked,
                onCellValueChanged: updateCellValue,
                cellEditor: 'agLargeTextCellEditor',
            },
            {
                headerName: "",                
                cellRenderer: (params) => {
                    const btn = document.createElement('button');
                    btn.innerHTML = '<i class="fa fa-trash"aria-hidden="true"></i>';
                    btn.style.cssText = 'background:none;border:none;cursor:pointer;font-size:16px;color:red;';
                    btn.title = 'Delete annotation';
                    btn.onclick = () => deleteAnnotation(params.data.id);
                    return btn;
                },                
                sortable: false,
                filter: false,
                flex: 1
            },
        ];

        const gridOptions = {
            columnDefs: columnDefs,
            rowData: [],
            defaultColDef: {
                resizable: true,
            },
            rowSelection: 'single',
            animateRows: true,
            getRowId: (params) => params.data.id,
            onRowSelected: (event) => {
                if (event.node.isSelected() && anno && !syncingSelection) {
                    syncingSelection = true;
                    anno.setSelected(event.data.id);
                    syncingSelection = false;
                }
            },
        };

        function initGrid() {
            const gridDiv = document.getElementById('myGrid');
            gridApi = agGrid.createGrid(gridDiv, gridOptions);
        }

        function showResult(elementId, data, isError = false) {
            const el = document.getElementById(elementId);
            el.style.display = 'block';
            el.textContent = JSON.stringify(data, null, 2);
            el.className = 'result ' + (isError ? 'error' : 'success');
        }

        async function selectFolder() {
            if (!apiReady) {
                showResult('loadResult', { error: 'API not ready' }, true);
                return;
            }

            try {
                const result = await window.pywebview.api.select_folder();

                if (!result.success) {
                    if (result.error !== 'No folder selected') {
                        showResult('loadResult', { error: result.error }, true);
                    }
                    return;
                }

                // Clear parent folder mode when selecting a single folder
                graptoFolders = [];
                currentFolderIndex = -1;
                hideSidebar();
                hideGlobalStats();

                const folderInfoEl = document.getElementById('folderInfo');
                let infoHtml = `<strong>Path:</strong> ${result.folder_path}<br>`;

                if (result.image_path) {
                    await displayImageFromPath(result.image_path);
                } else {
                    clearImage();
                }

                if (result.yaml_path) {
                    document.getElementById('yamlPath').value = result.yaml_path;
                    selectedYamlPath = result.yaml_path;
                    await loadYaml();

                    // Fetch and display label statistics
                    const stats = await window.pywebview.api.get_label_statistics();
                    if (stats.success && Object.keys(stats.label_counts).length > 0) {
                        infoHtml += '<strong>Labels:</strong><br>';
                        infoHtml += formatLabelCounts(stats.label_counts);
                    } else {
                        infoHtml += '<span class="file-missing">No annotations found</span>';
                    }
                } else {
                    infoHtml += '<span class="file-missing">No YAML file found</span>';
                }

                folderInfoEl.innerHTML = infoHtml;

            } catch (e) {
                showResult('loadResult', { error: e.message }, true);
            }
        }

        async function selectParentFolder() {
            if (!apiReady) {
                showResult('loadResult', { error: 'API not ready' }, true);
                return;
            }

            try {
                const result = await window.pywebview.api.select_parent_folder();

                if (!result.success) {
                    if (result.error !== 'No folder selected') {
                        showResult('loadResult', { error: result.error }, true);
                    }
                    return;
                }

                graptoFolders = result.folders;
                currentFolderIndex = -1;

                populateSidebar(result.folders);
                showSidebar();
                clearCurrentView();

                // Display global label statistics
                if (result.global_label_counts) {
                    displayGlobalStats(result.global_label_counts, result.global_total);
                }

                const folderInfoEl = document.getElementById('folderInfo');
                folderInfoEl.innerHTML = `<strong>Parent folder:</strong> ${result.folders.length} .grapto folders found`;

            } catch (e) {
                showResult('loadResult', { error: e.message }, true);
            }
        }

        function populateSidebar(folders) {
            const listEl = document.getElementById('folderList');
            listEl.innerHTML = '';

            folders.forEach((folder, index) => {
                const li = document.createElement('li');
                li.className = 'sidebar-item';
                li.dataset.index = index;
                li.innerHTML = `
                    <span class="folder-icon"><i class="fa fa-folder"></i></span>
                    <span class="folder-name" title="${folder.name}">${folder.name}</span>
                `;
                li.onclick = () => {
                    clearCurrentView();
                    loadGraptoFolder(index);
                };
                listEl.appendChild(li);
            });
        }

        async function loadGraptoFolder(index) {
            if (!apiReady || index === currentFolderIndex) {
                return;
            }

            const items = document.querySelectorAll('.sidebar-item');
            items.forEach(item => item.classList.remove('active', 'loading'));
            const currentItem = items[index];
            currentItem.classList.add('loading');

            try {
                const result = await window.pywebview.api.load_grapto_folder(index);

                if (!result.success) {
                    showResult('loadResult', { error: result.error }, true);
                    currentItem.classList.remove('loading');
                    return;
                }

                currentFolderIndex = index;

                items.forEach(item => item.classList.remove('active', 'loading'));
                currentItem.classList.add('active');

                const folderInfoEl = document.getElementById('folderInfo');
                let infoHtml = `<strong>Path:</strong> ${result.folder_path}<br>`;

                if (result.image_path) {
                    await displayImageFromPath(result.image_path);
                }

                if (result.yaml_path) {
                    document.getElementById('yamlPath').value = result.yaml_path;
                    selectedYamlPath = result.yaml_path;
                    await loadYaml();

                    // Fetch and display label statistics
                    const stats = await window.pywebview.api.get_label_statistics();
                    if (stats.success && Object.keys(stats.label_counts).length > 0) {
                        infoHtml += '<strong>Labels:</strong><br>';
                        infoHtml += formatLabelCounts(stats.label_counts);
                    } else {
                        infoHtml += '<span class="file-missing">No annotations found</span>';
                    }
                }

                folderInfoEl.innerHTML = infoHtml;

            } catch (e) {
                showResult('loadResult', { error: e.message }, true);
                currentItem.classList.remove('loading');
            }
        }

        function showSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.add('visible');
            sidebarVisible = true;
        }

        function hideSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.remove('visible');
            sidebarVisible = false;
        }

        function toggleSidebar() {
            if (sidebarVisible) {
                hideSidebar();
            } else {
                showSidebar();
            }
        }

        function clearCurrentView() {
            clearImage();

            if (gridApi) {
                gridApi.setGridOption('rowData', []);
            }

            if (anno) {
                anno.clearAnnotations();
                anno.destroy();
                anno = null;
            }

            document.getElementById('loadResult').style.display = 'none';
            selectedYamlPath = '';
            document.getElementById('yamlPath').value = '';
        }

        async function displayImageFromPath(imagePath) {
            try {
                const result = await window.pywebview.api.get_image_base64(imagePath);
                if (result.success) {
                    const container = document.getElementById('imageContainer');
                    container.innerHTML = '';

                    // Wait for OpenSeadragon to fully load the image
                    await new Promise((resolve) => {
                        viewer = OpenSeadragon({
                            element: container,
                            prefixUrl: "https://cdn.jsdelivr.net/npm/openseadragon@5.0/build/openseadragon/images/",
                            tileSources: {
                                type: 'image',
                                url: result.data
                            },   
                            gestureSettingsMouse: {
                                clickToZoom: false,
                                dblClickToZoom: false,
                                dblClickDragToZoom: false,
                            }
                        });
                        viewer.addHandler('open', function() {
                            console.log('Image loaded into OpenSeadragon');
                            resolve();
                        });
                    });

                    anno = AnnotoriousOSD.createOSDAnnotator(viewer, {
                        drawingEnabled: true, 
                        autoSave: true                         
                    });               
                    anno.setStyle({
                        fill: '#FFEA2E',
                        fillOpacity: 0.1,
                        stroke: '#FFEA2E',
                        strokeOpacity: 1
                    });                                        
                    anno.on('selectionChanged', function(annotations, originalEvent){   
                        try{
                            if (gridApi && !syncingSelection && annotations.length > 0) {                            
                                syncingSelection = true;
                                let annotation = annotations[0];                            
                                const rowNode = gridApi.getRowNode(annotation.id);
                                if (rowNode) {
                                    rowNode.setSelected(true);
                                    gridApi.ensureNodeVisible(rowNode, 'middle');
                                }
                                syncingSelection = false;
                            }
                        }catch(e){
                            syncingSelection = false;
                            console.error('Error in selectionChanged handler:', e);                            
                        }finally{
                            syncingSelection = false;
                        }                                         
                    });
                    anno.on('updateAnnotation', function(updated, previous){
                        const geometry = updated.target.selector.geometry;
                        updateAnnotationCoordinates(updated.id, geometry);
                    });
                    anno.on('createAnnotation', function(annotation) {
                        // Show label popup and store the annotation temporarily
                        showLabelPopup(annotation);
                    });
                } else {
                    console.error('Failed to load image:', result.error);
                    clearImage();
                }
            } catch (e) {
                console.error('Error loading image:', e);
                clearImage();
            }
        }        

        function clearImage() {
            const container = document.getElementById('imageContainer');
            container.innerHTML = '<div class="image-placeholder">No image loaded. Select a folder containing an image file.</div>';
            viewer?.destroy();
            viewer = null;
        }

        function getImageSize(){               
            return [viewer.world._contentSize.x, viewer.world._contentSize.y];
        }

        function calculateGeometryFromCropRegion(cropRegion) {
            if (!cropRegion) return null;                    
            const [imgWidth, imgHeight] = getImageSize();            
            let x = (cropRegion["x_center"] - cropRegion["width_relative"]/2)*imgWidth;
            let y = (cropRegion["y_center"] - cropRegion["height_relative"]/2)*imgHeight;
            let width = cropRegion["width_relative"]*imgWidth;
            let height = cropRegion["height_relative"]*imgHeight;
            return {x, y, width, height};
        }

        function calculateCropRegionFromGeometry(geometry) {
            const [imgWidth, imgHeight] = getImageSize();                        
            const width_relative = geometry.w / imgWidth;
            const height_relative = geometry.h / imgHeight;
            const x_center = (geometry.x / imgWidth) + (width_relative / 2);
            const y_center = (geometry.y / imgHeight) + (height_relative / 2);
            return { x_center, y_center, width_relative, height_relative };
        }

        async function updateAnnotationCoordinates(annotationId, geometry) {
            const cropRegion = calculateCropRegionFromGeometry(geometry);
            try {
                const result = await window.pywebview.api.update_node_coordinates(annotationId, cropRegion);
                if (!result.success) {
                    console.error('Failed to update annotation coordinates:', result.error);
                    return;
                }
                const display_data = result.rows.filter(row => row.type === "collectra.ImageCrop");
                gridApi.setGridOption('rowData', display_data);
                // Reload annotations on the image
                anno.clearAnnotations();
                display_data.forEach(row => {
                    const geom = calculateGeometryFromCropRegion(row.crop_region);
                    if (!geom) return;
                    anno.addAnnotation(createAnnotation(geom, row));
                });
                await fetchAvailableLabels();
            } catch (e) {
                console.error('Error updating annotation coordinates:', e);
            }
        }

        function createAnnotation(geometry, data) {
            let annotation = {
                id: data.id,
                target:{
                    selector:{
                        type: 'RECTANGLE',
                        geometry: {
                            bounds: {
                                minX: geometry.x,
                                minY: geometry.y,
                                maxX: geometry.x + geometry.width,
                                maxY: geometry.y + geometry.height
                            },
                            x: geometry.x,
                            y: geometry.y,
                            w: geometry.width,
                            h: geometry.height
                        }
                    }
                },
                bodies:[
                    data
                ]                
            };            
            return annotation;
        }

        async function loadGridData() {
            try {
                const result = await window.pywebview.api.get_all_nodes_for_grid();                
                if (result.success) {
                    display_data = result.rows.filter(row => row.type === "collectra.ImageCrop");                    
                    gridApi.setGridOption('rowData', display_data);                                        
                    anno.clearAnnotations();                                                
                    display_data.forEach(row => {                        
                        const geometry = calculateGeometryFromCropRegion(row.crop_region);
                        if (!geometry) return;                                                          
                        anno.addAnnotation(createAnnotation(geometry, row));
                    });
                } else {
                    console.error('Failed to load grid data:', result.error);
                }
            } catch (e) {
                console.error('Error loading grid data:', e);
            }
        }

        async function loadYaml() {
            const path = document.getElementById('yamlPath').value;
            if (!path) {
                showResult('loadResult', { error: 'No YAML file selected' }, true);
                return;
            }
            try {
                const result = await window.pywebview.api.load_yaml(path);
                showResult('loadResult', result, !result.success);
                if (result.success) {
                    await loadGridData();
                    await fetchAvailableLabels();
                }
            } catch (e) {
                showResult('loadResult', { error: e.message }, true);
            }
        }

        window.addEventListener('pywebviewready', function() {
            apiReady = true;
            const statusEl = document.getElementById('status');
            statusEl.className = 'status connected';
            statusEl.textContent = 'pywebview API ready';
            document.getElementById('selectFolderBtn').disabled = false;
            document.getElementById('selectParentBtn').disabled = false;
            initGrid();
        });
    </script>
</body>
</html>
